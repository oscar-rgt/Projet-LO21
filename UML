@startuml
skinparam classAttributeIconSize 0

' =============================
' Classes conceptuelles
' =============================

class Partie {
  -id : int
  +mode : enum = {solo,multi}
  -joueurs : Joueur[1..4]
  -nbJoueurs : int 
  -pileTuiles : Pile*
  +Partie(id_ : int, m : Mode, pile : Pile*)
  +ajouterJoueur(j : Joueur*) : bool
  +getId() : int
  +getMode() : Mode
  +getNbJoueurs() : int
  +getJoueur(index : int) : Joueur* const
  +getPile() : Pile* const
  +jouerTours()
}

class Pile {
  -id : int
  -nbTuiles : int
  +Pile(id_ : int, nb : int)
  +retirerTuile() : bool
}

class Joueur {
  -nom : string
  -points : int
  -pierres : int
  +Joueur(n : const string&)
  +getNom() : const string& const
  +getPoints() : int const
  +getPierres() : int const
  +setPoints(p : int)
  +ajouterPoints(delta : int)
  +ajouterPierre(n : int)
  +utiliserPierre(n : int) : bool
  +ajouterPierresRecouvrement(nbRecouverts : int)
}


class Score {
  -joueur : Joueur*
  -cite : Cite*
  -pointsParType : map<TypeQuartier,int>
  -total : int
  +Score(j : Joueur*, c : Cite*)
  +calculerScore()
  +calculerScoreType(type : TypeQuartier) : int
  +getTotal() : int const
  +getScoreType(type : TypeQuartier) : int const
  +getJoueur() : const Joueur* const
}


class Cite {
  -carte: map<Coord, Hexagone&, CoordHash>
  -voisinsTuile(c : Coord) : vector<Coord>
  +placer(t : Tuile*, c : Coord)
  +estLibre(c : Coord) : bool 
}


class Tuile {
  -orientation : Orientation
  -id : unsigned int
  -prix : unsigned int
  -hexagone[3] : Hexagone
  -Tuile(i:unsigned int, h1:Hexagone&, h2:Hexagone&, h3:Hexagone&, o: Orientation, p:unsigned int)
  -~Tuile()
  -operator=(h:const Hexagone&) : Hexagone&
  +Hexagone(h:const Hexagone&)
  +getOrientation() : Orientation const
  +getHexagone() : Hexagone&
  +getId() : unsigned int const
  +getPrix() : unsigned int const
}

class Hexagone {
  -niveau: int
  -etoiles: int
  -type: Type
  -recouvert: bool
  -Hexagone(t: Type, n: int, r: bool, e: int)
  -Hexagone()
  -recouvrir(r:bool)
  -operator=(h:const Hexagone&) : Hexagone& 
  -~Hexagone()
  +getType() : Type const
  +getNiveau() : int const
  +est_recouvert() : bool const
  +getEtoiles() : int const
  +affiche()
  +Hexagone(h:const Hexagone&)
  
  
}
struct Coord{
  x : int
  y : int
  z : int
  sudOuest() : Coord 
  sudEst() : Coord
  operator==(other: const Coord&) : bool
}

struct CoordHash{
  operator()(c: const Coord&) : size_t const 
}

enum Orientation{
  N
  SE
  SO
}

enum TypeHexa{
  Carriere
  Habitation
  Marche
  Caserne
  Temple
  Jardin
  Place
}

enum TypeQuartier{
  Habitation
  Marche
  Caserne
  Temple
  Jardin
}

class Variante {
  nom : str
  regle : str
}

class IllustreConstructeur {
  difficulte : enum={facile,moyen,difficile}
}

' =============================
' Relations
' =============================
Tuile ..> Orientation
Hexagone ..> TypeHexa
Score ..> TypeQuartier
Cite ..> Coord
Cite ..> CoordHash
CoordHash ..> Coord


Partie *-right- "1..*" Pile : est composée de >
Partie o-down- "1..4" Joueur : est jouée par >
Partie o-left- "0..*" Variante : est jouée avec >
Partie o-up- "0..1" IllustreConstructeur : utilise >

Joueur  *-- "1" Cite : possede >
Cite "1" -- "0..*" Hexagone : contient >
Score -left-*Joueur
Hexagone "3"-left-*"1"Tuile : est composé de <


@enduml
