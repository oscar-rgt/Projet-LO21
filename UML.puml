@startuml
' Configuration Générale
skinparam ClassAttributeIconStyle none
skinparam enum {
    BackgroundColor palegreen
    BorderColor darkgreen
}

' =========================================================
' 1. STRUCTS, ENUMS et CLASSES FONDAMENTALES
' =========================================================

struct Coord {
    + x : int
    + y : int
    + z : int
    + sud() : Coord 
    + cote(bool) : Coord
    + operator==(Coord&) : bool
}

struct CoordHash {
    + operator()(Coord&) : size_t 
}

struct InfoHexa {
    + type : int
    + etoiles : int
    + estPlace : int
}

struct Action {
    + tuileId : int
    + x, y, z : int
    + inversion : bool
    + hexas[3] : InfoHexa ' Relation de Composition implicite
}
Action "1" *-- "3" InfoHexa

enum TypeQuartier {
    Habitation
    Marche
    Caserne
    Temple
    Jardin
    Carriere
}

enum TuileCite {
    STANDARD
    AUGMENTE
}

class Hexagone {
    - niveau : int
    - etoiles : int
    - type : TypeQuartier
    - tuile : Tuile*
    - place : bool
    + getType() : TypeQuartier
    + getNiveau() : int
    + getTuile() : Tuile* + getEtoiles() : int
    + affiche() : string  
    + setNiveau(int) : void
    + estPlace() : bool
}

class Tuile {
  #inversion : bool
  #id : int
  #prix : int
  #design : string
  #hexagones : vector<Hexagone*>
  +getHexagone(int) : Hexagone*
  +getNbHexagones() : size_t
  +getId() : int
  +getInversion() : bool
  +inverser() : bool
  +getPrix() : int 
  +tourner() : void
  +setPrix(int) : void
  +getDesign() : string&
  +reconstruireHexagone(int, int, int) : void
}

class TuileDepart 

Tuile <|-- TuileDepart
Tuile "1" *-- "1..4" Hexagone : hexagones

' =========================================================
' 2. CLASSES D'ORGANISATION (Jeu)
' =========================================================

class Chantier {
    - tuiles : vector<Tuile*>
    ' ... méthodes ...
    + begin() : Iterator
    + end() : Iterator
}

class Pile {
    - id : unsigned int
    - tuiles : vector<Tuile*>
    ' ... méthodes ...
    + begin() : Iterator
    + end() : Iterator
}

class Cite {
    - carte : map<Coord, Hexagone*, CoordHash>
    - quadrillage : string
    - t : TuileDepart*
    - historique : vector<Action>
    ' ... méthodes ...
    + begin() : ConstIterator
    + end() : ConstIterator
}
Cite "1" *-- "0..*" Action : historique
Cite "1" o-- "0..*" Hexagone : carte
Cite "1" *-- "1" TuileDepart : tuileDepart
Cite ..> Coord
Cite ..> CoordHash

' Classes pour les Itérateurs de classes non imbriquées
class ChantierIterator {
    ' Remplacé par Chantier::Iterator pour la cohérence des noms de classes
    - current : vector<Tuile*>::const_iterator
    ' ... méthodes ...
}
Chantier "1" *-- "1" ChantierIterator : <<crée>>
ChantierIterator .> Tuile : accède à

class CiteConstIterator {
    ' Remplacé par ConstIterator pour la cohérence des noms de classes
    - current : unordered_map<Coord, Hexagone*, CoordHash>::const_iterator
    ' ... méthodes ...
}
Cite "1" *-- "1" CiteConstIterator : <<crée>>
CiteConstIterator .> Hexagone : accède à

' =========================================================
' 3. CLASSES IMBRIQUÉES / ITÉRATEURS
' =========================================================
' Chantier::Iterator -> Renommé en ChantierIterator (voir ci-dessus pour éviter confusion)

' Pile::Iterator (Utilisation du nom complet pour l'imbrication si on ne veut pas de namespace)
class Pile_Iterator {
    - current : vector<Tuile*>::const_iterator
    + operator++() : Pile_Iterator&
    + operator!=(Pile_Iterator&) : bool
    + operator*() : Tuile*
}
Pile "1" *-- "1" Pile_Iterator : <<crée>>
Pile_Iterator .> Tuile : accède à


' =========================================================
' 4. CLASSES JOUEUR ET CONTEXTE
' =========================================================
class Joueur {
    - nom : string
    - score : Score*
    - pierres : int
    - cite : Cite*
    ' ... méthodes ...
}

class IA {
    - difficulte : int
    - tuilesAcquises : vector<Tuile*>
    ' ... méthodes ...
}

class Score {
    - joueur : Joueur*
    - total : int
    - strategies : map<TypeQuartier, RegleScore*>
    - pointsParType : map<TypeQuartier, int>
    ' ... méthodes ...
}

Joueur "1" *-- "1" Cite : possède
Joueur "1" -- "1" Score : calculé par
Score ..> TypeQuartier
Joueur --|> IA

' =========================================================
' 5. PATTERN STRATÉGIE (SCORE)
' =========================================================
abstract class RegleScore <<interface>> {
    + {abstract} calculer(Cite*) : int
    + {abstract} getNom() : string
    # compterEtoiles(Cite*, TypeQuartier) : int
}

Score "1" o-- "0..*" RegleScore : strategies
RegleScore .> Cite : utilise

' Hiérarchie complète
RegleScore <|-- RegleHabitation
RegleHabitation <|-- RegleHabitationVariante
RegleScore <|-- RegleMarche
RegleMarche <|-- RegleMarcheVariante
RegleScore <|-- RegleCaserne
RegleCaserne <|-- RegleCaserneVariante
RegleScore <|-- RegleTemple
RegleTemple <|-- RegleTempleVariante
RegleScore <|-- RegleJardin
RegleJardin <|-- RegleJardinVariante

' Classes concrètes de règles (simples, sans contenu pour la concision)
class RegleHabitation
class RegleHabitationVariante
class RegleMarche
class RegleMarcheVariante
class RegleCaserne
class RegleCaserneVariante
class RegleTemple
class RegleTempleVariante
class RegleJardin
class RegleJardinVariante

' =========================================================
' 6. CLASSE PARTIE (SINGLETON) et UTILS
' =========================================================
class Partie << (S, #FF7777) Singleton >> {
    - tuilesDepart : vector<Tuile*>
    - niveauIA : int
    - modeTuileCite : TuileCite
    - chantier : Chantier
    - piles : vector<Pile*>
    - joueurs : vector<Joueur*>
    - indexPileActuelle : int
    - indexJoueurActuel : int
    - variantes : array<bool,5>
    ' ... méthodes privées ...
    {static} + getInstance() : Partie&
    ' ... méthodes publiques ...
}

class Variante {
    + nom : string
    + regle : string
}

class JeuConsole {
    - modeTuileCite : TuileCite
    - nomsJoueurs : vector<string>
    - variantesActives : array<bool,5>
    ' ... méthodes ...
}

class Sauvegarde {
    {static} + savePartie(string&) : bool
    ' ... méthodes statiques ...
}

' =========================================================
' 7. RELATIONS PARTIE
' =========================================================

' Relations d'Agrégation / Composition
Partie "1" *-- "1" Chantier : chantier
Partie "1" *-- "0..*" Pile : piles
Partie "1" *-- "0..*" Joueur : joueurs
Partie "1" o-- "0..*" Tuile : tuilesDepart

' Dépendances
Partie ..> TuileCite : mode
Partie ..> Sauvegarde
JeuConsole ..> Partie
JeuConsole ..> TuileCite

' Itérateurs de Partie
class PartieJoueurIterator {
    - current : vector<Joueur*>::iterator
    ' ... méthodes ...
}
class PartiePileIterator {
    - current : vector<Pile*>::const_iterator
    ' ... méthodes ...
}

Partie "1" *-- "1" PartieJoueurIterator : <<crée>>
Partie "1" *-- "1" PartiePileIterator : <<crée>>
PartieJoueurIterator .> Joueur : accède à
PartiePileIterator .> Pile : accède à
@endumlal